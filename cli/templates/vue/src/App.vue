<template>
  <div v-if="loadingError" class="error-container">
    <h2>Error</h2>
    <p>{{ loadingError }}</p>
  </div>

  <div v-else-if="!schema" class="loading-container">
    <p>Loading...</p>
  </div>

  <div v-else class="app">
    <Header
      :title="schema.title || 'OpenSCAD Customizer'"
      :description="schema.description"
      @copy-link="handleCopyLink"
    />
    
    <main class="container">
      <div class="layout">
        <ParametersPanel
          :schema="schema"
          :parameters="parameters"
          @change="handleParameterChange"
        />
        
        <PreviewPanel
          :stl-data="stlData"
          :preview-state="previewState"
          :error="error"
          @render="handleRender"
          @download="handleDownload"
        />
      </div>
    </main>
    
    <footer class="footer">
      <p>
        Generated by OpenSCAD Assistive Forge â€¢
        <a href="https://github.com/BrennenJohnston/openscad-assistive-forge">
          Source Code
        </a>
      </p>
    </footer>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue';
import Header from './components/Header.vue';
import ParametersPanel from './components/ParametersPanel.vue';
import PreviewPanel from './components/PreviewPanel.vue';

const schema = ref(null);
const scadSource = ref('');
const parameters = ref({});
const previewState = ref('idle');
const stlData = ref(null);
const error = ref(null);
const loadingError = ref(null);
let worker = null;

// Load schema and SCAD source from embedded scripts
onMounted(() => {
  try {
    const schemaElement = document.getElementById('param-schema');
    const scadElement = document.getElementById('scad-source');

    if (!schemaElement || !scadElement) {
      throw new Error('Missing embedded schema or SCAD source');
    }

    const loadedSchema = JSON.parse(schemaElement.textContent);
    const loadedScad = scadElement.textContent;

    schema.value = loadedSchema;
    scadSource.value = loadedScad;

    // Initialize parameters with defaults
    const defaultParams = {};
    for (const [key, prop] of Object.entries(loadedSchema.properties || {})) {
      defaultParams[key] = prop.default;
    }

    // Load parameters from URL hash if present
    if (window.location.hash) {
      const urlParams = parseUrlParams(window.location.hash.slice(1));
      parameters.value = { ...defaultParams, ...urlParams };
    } else {
      parameters.value = defaultParams;
    }
  } catch (err) {
    loadingError.value = `Failed to load schema: ${err.message}`;
  }
});

// Parse URL parameters
const parseUrlParams = (hash) => {
  const params = {};
  const pairs = hash.split('&');
  for (const pair of pairs) {
    const [key, value] = pair.split('=');
    if (key && value) {
      params[decodeURIComponent(key)] = JSON.parse(decodeURIComponent(value));
    }
  }
  return params;
};

// Update URL hash when parameters change
watch([parameters, schema], () => {
  if (!schema.value) return;
  
  const pairs = [];
  for (const [key, value] of Object.entries(parameters.value)) {
    pairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(JSON.stringify(value))}`);
  }
  window.history.replaceState(null, '', `#${pairs.join('&')}`);
}, { deep: true });

// Handle parameter changes
const handleParameterChange = (name, value) => {
  parameters.value = { ...parameters.value, [name]: value };
  previewState.value = 'pending';
};

// Render STL
const handleRender = async () => {
  if (!worker) {
    worker = new Worker(new URL('./worker/openscad-worker.js', import.meta.url), {
      type: 'module',
    });
  }

  previewState.value = 'rendering';
  error.value = null;

  // Create promise to handle worker response
  const renderPromise = new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Render timeout (60s)'));
    }, 60000);

    const handleMessage = (e) => {
      clearTimeout(timeout);
      worker.removeEventListener('message', handleMessage);

      if (e.data.type === 'render-complete') {
        resolve(e.data.stl);
      } else if (e.data.type === 'render-error') {
        reject(new Error(e.data.error));
      }
    };

    worker.addEventListener('message', handleMessage);
  });

  try {
    // Convert parameters to OpenSCAD format
    const scadParams = Object.entries(parameters.value).map(([key, value]) => {
      if (typeof value === 'string') {
        return `${key}="${value}";`;
      }
      return `${key}=${JSON.stringify(value)};`;
    });

    const paramString = scadParams.join('\n');
    const fullSource = `${paramString}\n\n${scadSource.value}`;

    worker.postMessage({
      type: 'render',
      source: fullSource,
    });

    const stl = await renderPromise;
    stlData.value = stl;
    previewState.value = 'current';
  } catch (err) {
    error.value = err.message;
    previewState.value = 'error';
  }
};

// Download STL
const handleDownload = () => {
  if (!stlData.value) return;

  const blob = new Blob([stlData.value], { type: 'model/stl' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `model_${Date.now()}.stl`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Copy share link
const handleCopyLink = () => {
  navigator.clipboard.writeText(window.location.href);
  alert('Share link copied to clipboard!');
};
</script>
